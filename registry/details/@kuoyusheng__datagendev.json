{
  "id": "@kuoyusheng/datagendev",
  "displayName": "DataGen",
  "description": "Run and orchestrate DataGen deployments from validation through execution and monitoring. Generate copy-ready curl commands, input/output schemas, and accessible Mermaid flowcharts to integrate and explain workflows. Build, test, and deploy Python automations, then schedule and track them with ease.",
  "createdAt": "2026-01-17T02:10:31.803Z",
  "links": {
    "homepage": "",
    "registry": "https://smithery.ai/server/@kuoyusheng/datagendev"
  },
  "connection": {
    "type": "http",
    "runtime": "node",
    "configSchema": {}
  },
  "capabilities": [
    {
      "name": "getDeploymentDetails",
      "description": "üîç Get comprehensive deployment details for easy copying to Clay or other tools.\n\n\t\t\tRetrieves complete information about a specific deployment including code, input examples,\n\t\t\tand ready-to-use curl commands for external integrations.\n\n\t\t\t**Perfect for:**\n\t\t\t- Getting curl commands for external API calls\n\t\t\t- Understanding deployment input/output schemas\n\t\t\t- Integrating deployments into external systems\n\n\t\t\t**Parameters:**\n\t\t\t- deployment_uuid: UUID of the deployment\n\t\t\t- brief: (optional, default: false) Set to true to get only essential information for LLM understanding (name, description, input/output schemas, and example values)\n\n\t\t\t**Returns:**\n\t\t\t- Complete deployment metadata and code (when brief=false)\n\t\t\t- Ready-to-copy curl commands for sync and async execution\n\t\t\t- Input/output schemas with examples\n\t\t\t- API endpoint information for external use\n\t\t\t- When brief=true: Only name, description, input_vars, input_schema, output_schema, and default_input_vars\n\t\t\t\n\t\t\t**üìä Create Accessible Mermaid Flowchart from Code:** After receiving the response, analyze the `final_code` field and create clear mermaid diagrams that help non-technical users understand and interact with the code:\n\t\t\t\n\t\t\t**üö® CRITICAL SYNTAX REQUIREMENT:** Always use double-quoted brackets for all nodes: `A[\"Node Content\"]` NOT `A[Node Content]`\n\t\t\t\n\t\t\t**Process Flow Structure:**\n\t\t\t- Use **top-to-bottom flowchart** format (`flowchart TD`)\n\t\t\t- Show **main workflow** with clear start and end points  \n\t\t\t- Include **decision points** (diamonds) for conditional logic\n\t\t\t- Use **descriptive labels** in plain English, avoiding technical jargon\n\t\t\t- Group related functions into **logical sections** with subgraphs when helpful\n\t\t\t\n\t\t\t**Function Details:** For each function/process box, include:\n\t\t\t- **Function name** in readable format (e.g., \"Get Repository Data\" instead of \"mcp_GitHub_get_repo()\")\n\t\t\t- **Key arguments/inputs** that users might want to modify\n\t\t\t- **Purpose** in simple terms (what it does, not how)\n\t\t\t- Format: `A[\"**Function Name**<br/>Purpose: [what it accomplishes]<br/>Input: [key parameters]\"]`\n\t\t\t\n\t\t\t**Data Classification** - Use color coding and styling:\n\t\t\t- üìù **User inputs** (blue/cyan boxes): Variables users can modify\n\t\t\t- ‚öôÔ∏è **Processing steps** (green boxes): Data transformation and logic\n\t\t\t- üîó **External calls** (orange boxes): MCP tools, APIs, external services\n\t\t\t- üìä **Outputs** (purple boxes): Final results and return values\n\t\t\t- üîÑ **Decision points** (yellow diamonds): Conditional logic and branching\n\t\t\t- ‚ö†Ô∏è **Hardcoded values** (red/pink boxes): Fixed data not user-configurable (URLs, API keys, constants)\n\t\t\t\n\t\t\t**Code Analysis Requirements:**\n\t\t\t- **Parse the `final_code`** to understand real processing workflow\n\t\t\t- **Extract function calls** especially MCP tool calls (starting with `mcp_`)\n\t\t\t- **Identify control flow** including if/else conditions, loops, try/catch blocks\n\t\t\t- **Map data transformations** showing how inputs become outputs\n\t\t\t- **Detect service interactions** between different tools and APIs\n\t\t\t- **Identify hardcoded values** that are embedded in code vs user-configurable\n\t\t\t- **Make technical concepts accessible** to non-technical users"
    },
    {
      "name": "validateDeploymentConnection",
      "description": "Validate deployment connection before executing a workflow. Recommend to use this tool before running a deployment.\n\t\tUse this to confirm that required MCP connections, secrets, and environment variables are configured for the authenticated user.\n\t\t\n\t\t**Returns (JSON text):**\n\t\t- `deployment_uuid`, `is_valid`, `status`, and `readiness_flag`\n\t\t- Compact `missing` object for environment variables, secrets, and MCP connections (with auth/URL hints)\n\t\t- `note` with a manage URL whenever secrets are missing\n\t\t- `next_steps` array describing remediation actions"
    },
    {
      "name": "submitDeploymentRun",
      "description": "Execute a deployed DataGen workflow with custom inputs.\n      \n      Use this to run pre-built workflows (like data processing pipelines, web scrapers, or automation scripts) that have been deployed as API endpoints. This starts an asynchronous execution - you'll get a run ID that you can monitor with 'checkRunStatus'.\n      \n      **Typical workflow:** \n\t  1. Use `validateDeploymentConnection` tool to validate the deployment and get the missing MCP or Secrets.\n      2. Use this tool to start a deployment\n      3. Get a run_uuid in response\n      4. Use `checkRunStatus` to monitor progress\n      5. Retrieve results when complete\n      \n      **Use cases:** Run data pipelines, execute scrapers, trigger automations, process files. \n\t  **Error handling:** If found any missing MCP or Secrets, try to run validate deployment connection tool to validate the deployment and get the missing MCP or Secrets."
    },
    {
      "name": "checkRunStatus",
      "description": "Monitor the progress and results of a running DataGen workflow with automatic polling.\n\n\t\tAfter starting a workflow with 'submitDeploymentRun', use this to check if it's still running, completed successfully, or failed. Provide a run UUID directly, or supply a deployment UUID to automatically locate the most recent run for that deployment.\n\n\t\t**Status types:**\n\t\t- 'pending': Waiting in queue, check again in a few seconds\n\t\t- 'running': Still executing, check again in a few seconds\n\t\t- 'completed': Finished successfully, output data available\n\t\t- 'failed': Execution failed, error details provided\n\n\t\t**Controls:**\n\t\t- 'timeout_seconds' (default 180, max 600) to cap how long to poll\n\t\t- 'poll_interval_seconds' (default 5, min 2, max 30) between checks\n\n\t\t**Lookup options:**\n\t\t- Provide 'run_uuid' for direct status polling\n\t\t- Provide 'deployment_uuid' to look up the latest run automatically"
    },
    {
      "name": "executeCode",
      "description": "Execute Python code with full access to MCP tools and data processing libraries.\n\t\t\n\t\tThis is your Python sandbox for building workflows, processing data, and integrating multiple tools. You can call MCP tools directly as Python functions (e.g., `mcp_Supabase_list_projects()`) and use libraries like pandas, requests, and more.\n\t\t\n\t\t**Key features:**\n\t\t- Call any tool as a Python function, including MCP tools\n\t\t- Rich execution logs and error handling\n\t\t- All the MCP tools(tool start with mcp_) output have been parsed by json.loads() already if its json parsable,If json.loads() fails, returns the original string\n\t\t- b/c MCP output schema may not be defined, always first try test the mcp tool output data structure. especially for user defined data like google sheet, airtable, supabase sql results.\n\n\t\t**Make sure to include the right MCP server name in mcp_server_names and tool name in the required_tools array.**\n\t\t- do not guess the tool name or server name. if its not in the context, use SearchTool tool to get the correct tool name and server name. before using this code execution tool\n\t\t- If you get back with 401 authorizied error. its very likely that you did not include the right server name in the mcp_server_names array. \n\t\t- If the required server is not installed, prompt user to install the server. with \"addRemoteMcpServer\" tool.\n\n\n\t\t**Do not use any local() or global() in the code.**\n\t\tyou can assume the input variables are already defined in the global scope. and you can use them directly with data type defined in the input_schema.\n\t\t**Do not use any async in the code. it will cause the code to not work.**\n\n\t\t** When work with API** \n\t\t- use httpx instead of requests.\n\t\t- if API key is needed, use getUserSecrets tool to get the API key. if not in their, prompt user to add the API key in Datagen.\n\t\t- when use API key just use the key like other variables. DO NOT USE os.getenv() to get the API key.\n\t\t- use polling if the API is async and you want to wait for the result.\n\n\t\t**Coding Style:**\n\t\t- use python 3.12 syntax.\n\t\t- Keep it simple and readable. do not use exntensive comments and logger. only necessary print out for debugging.\n\t\t- Focus on the main logic and do not add unnecessary code.\n\n\t\t**Error handling:**\n\t\t- If you get back with 401 authorizied error. its very likely that you did not include the right server name in the mcp_server_names array or missing required_tools. \n\t\t- If you have trouble to parse the tool response, try to use the native tool call to observe the response structure. \n\t\t- <example>\n\t\tif you get parsing erro with mcp_Supabase_list_projects(), try to use the user's native list_projects tool in LLM client(like Cursor or Claude) to get the response structure.\n\t\t</example>\n\t\t\n\t\t**See the 'how to use executeCode' resource for detailed examples and best practices.**"
    },
    {
      "name": "asyncExecuteCode",
      "description": "Execute Python code asynchronously for long-running operations.\n\t\t\n\t\tThis tool starts Python code execution in the background and returns immediately with an execution UUID. Use 'checkCodeExecStatus' to monitor progress and retrieve results. Perfect for long-running scripts, large data processing, or operations that might take several minutes.\n\t\tcall this tool when you are dealing with long running operations.\n\t\t\n\t\t**Key advantages over executeCode:**\n\t\t- Non-blocking execution\n\t\t- No timeout limitations \n\n\t\t\n\t\t**Workflow:**\n\t\t1. Call this tool to start execution\n\t\t2. Get execution_uuid in response\n\t\t3. Use 'checkCodeExecStatus' to monitor progress\n\t\t4. Retrieve results when status is 'completed'\n\t\t\n\t\t**Do not use any local() or global() in the code.**\n\t\t**Do not use any async in the code. it will cause the code to not work.**\n\t\t**When work with API directly, use httpx instead of requests.**\n\t\t"
    },
    {
      "name": "checkCodeExecStatus",
      "description": "Monitor the progress and retrieve results of asynchronous code execution with automatic polling.\n\n\t\tAfter starting code execution with 'asyncExecuteCode', use this tool to check the current status and get results when complete. This tool provides real-time updates on execution progress.\n\n\t\t**Status types:**\n\t\t- 'pending': Execution queued but not yet started\n\t\t- 'running': Currently executing your code\n\t\t- 'completed': Finished successfully, results available\n\t\t- 'failed': Execution failed, error details provided\n\t\t- 'cancelled': Execution was cancelled\n\n\t\t**Controls:**\n\t\t- 'timeout_seconds' (default 300, max 900) to cap how long to poll\n\t\t- 'poll_interval_seconds' (default 5, min 2, max 30) between checks\n\n\t\t**Tip:** For long operations, poll every 10-30 seconds until completion."
    },
    {
      "name": "getToolDetails",
      "description": "Get comprehensive documentation for any specific tool. \n\t\t\tyou use it to find the tool details and the server name to use in code execution tool."
    },
    {
      "name": "searchTools",
      "description": "üîé Find tools by functionality, keywords, or provider.\n\t\t\n\t\tSmart search across all available tools when you know what you want to accomplish but aren't sure which specific tool to use. Search by functionality, keywords, or filter by tool type and provider.\n\t\t\n\t\t**Search examples:**\n\t\t- \"database\" ‚Üí Find all database-related tools\n\t\t- \"web scraping\" ‚Üí Discover scraping and data extraction tools  \n\t\t- \"Supabase\" ‚Üí All Supabase integration tools\n\t\t- \"file upload\" ‚Üí Tools for handling file operations\n\t\t\n\t\t**Filters help you** narrow down to exactly what you need - specific providers, etc."
    },
    {
      "name": "deployCode",
      "description": "Deploys working Python code as a DataGen standalone deployment.\n\t\t\t\tThis tool orchestrates the complete workflow: takes your Python code, tests it, \n\t\t\t\tand creates a standalone deployment as an API endpoint with default values.\n\t\t\t\tPerfect for converting working code into a production-ready deployment without flows.\n\t\t\t\t\n\t\t\t\tUses OpenAPI/JSON Schema for rich input and output validation with descriptions, \n\t\t\t\ttype constraints, default values, and comprehensive documentation.\n\t\t\t\n\t\t\t\t**Schema Example:**\n\t\t\t\tinput_schema: {\n\t\t\t\t  'type': 'object',\n\t\t\t\t  'properties': {\n\t\t\t\t    'name': {'type': 'string', 'description': 'User name'},\n\t\t\t\t    'count': {'type': 'integer', 'minimum': 1, 'default': 10},\n\t\t\t\t    'data': {'type': 'array', 'items': {'type': 'string'}}\n\t\t\t\t  },\n\t\t\t\t  'required': ['name']\n\t\t\t\t}\n\t\t\t\n\t\t\t**Do not use any local() or global() in the code.**\n\t\t\tyou can assume the input variables are already defined in the global scope. and you can use them directly with data type defined in the input_schema.\n\t\t\t\n\t\t\t**Do Not Return anthing for Output** \n\t\t\tDeploy code use the globa variable to reference the input and output variables. so do not return in main script. otherwise it would trigger ReturnException. \n\t\t\tTo return output, just reference the global variable. \n\n\t\t\tfor example: \n\t\t\tif I need to return the output variable \"result\" in the main script, I can do this:\n\t\t\t\n\t\t\tresult = \"Hello, World!\"\n\n\t\t\tand in the output_variables, I can do this:\n\t\t\toutput_variables: ['result']\n\t\t\tjust simply reference the global variable in the output_variables.\n\n\t\t\t**No Async in the code**\n\t\t\tDo not use any async in the code. it will cause the code to not work.\n\n\t\t\t**Steps to take before deploying code**\n\t\t\t<step0> Try to briefly explain the code or plan to the user. </step0>\n\t\t\t<step1> Come up with right input_schema and output_schema to define the input and output variables </step1>\n\t\t\t<step2> Confirm with user if the input and output are correct. modify if needed. </step2>\n\t\t\t<step3> Run submitDeploymentRun tool to test the code is working on Datagen after the deployment is created. </step3>\n\t\t\t"
    },
    {
      "name": "addRemoteMcpServer",
      "description": "Add a remote MCP server with OAuth or direct URL to DataGen. \n\t\t\t\n\t\t\t<Find Remote MCP Server URL>\n\t\t\tBefore adding a remote MCP server, and if you have web research tool, you should first search and find the officail remote MCP server with their URL. \n\t\t\tIf No official remote MCP available, recommend user to look for MCP hosted services \n\t\t\tlike smithery.ai(https://smithery.ai), Klavis AI(https://klavis.ai), etc. to add the remote MCP server. \n\t\t\t</Find Remote MCP Server URL>\n\n\t\t\t<Add Remote MCP Server>\n\t\t\tDirectly add remote MCP servers by providing server name, and URL\n\t\t\t</Add Remote MCP Server>\n\n\t\t\tSupports OAuth flows. Returns available tools upon successful connection.\n\t\t\n\t\t\tPerfect for:\n\t\t\t- Connecting to external MCP services to DataGen\n\t\t\t\n\t\t\tInput Requirements:\n\t\t\t- server_name: Display name for the server (must follow naming rules)\n\t\t\t- server_url: Remote server endpoint (HTTP/SSE)\n\t\t\t\n\t\t\tNaming Rules:\n\t\t\t- Use only alphanumeric characters (no spaces, underscores, or dashes)\n\t\t\t- Start with an uppercase letter\n\t\t\t- Use CamelCase for multiple words\n\t\t\t- Examples: 'GitHub', 'Slack', 'GoogleDrive'\n\t\t\t\n\t\t\tReturns: \n\t\t\t- Server info + complete list of available tools with descriptions or auth url if OAuth is required.\n\t\t\t- if success is false, it means the server is not found or the URL is not valid.\n\t\t\t- if Auth url is returned, plese use the proper formating like [Auth url](https://your-auth-url.com) to format the auth url.\n\t\t\t and use checkRemoteMcpOauthStatus tool to check the status of the OAuth flow right after this tool call.\n\t\t\t"
    },
    {
      "name": "checkRemoteMcpOauthStatus",
      "description": "Check the status of an OAuth flow for remote MCP server connection with polling.\n\n\t\t\tAfter receiving an OAuth redirect URL from addRemoteMcpServer, use this tool to check if the user has completed authentication. This tool will poll the status until completion or timeout.\n\n\t\t\t**Use this when:**\n\t\t\t- addRemoteMcpServer returned requires_auth: true\n\t\t\t- User has completed OAuth authentication in browser\n\t\t\t- You want to confirm the server connection is established\n\n\t\t\t**Returns:** Final connection status on success, or error details on failure/timeout\n\n\t\t\t**Next steps after success:**\n\t\t\t- When status is \"completed\", the MCP server is now connected and ready\n\t\t\t- Use 'searchTools' to discover what tools are available from the newly connected server\n\t\t\t- Example: searchTools({query: \"server_name\", tool_type: \"mcp\"})"
    },
    {
      "name": "ReAuthRemoteMcpServer",
      "description": "üîÑ Reauthenticate an existing remote MCP server connection.\n\t\t\t\n\t\t\tWhen an existing remote MCP server's OAuth tokens have expired or become invalid, use this tool to initiate a fresh authentication flow. This will start a new OAuth flow while preserving the server configuration.\n\t\t\t\n\t\t\t**Use this when:**\n\t\t\t- Server tools stop working due to expired tokens\n\t\t\t- You receive authentication errors from MCP tools\n\t\t\t- OAuth tokens need to be refreshed for a connected server\n\t\t\t- Server connection has been lost and needs re-authentication\n\t\t\t\n\t\t\t**Process:**\n\t\t\t1. Call this tool with the server name (must follow naming rules)\n\t\t\t2. If OAuth is required, you'll get an auth_url\n\t\t\t3. Complete authentication in the browser\n\t\t\t4. Use checkRemoteMcpOauthStatus to verify completion\n\t\t\t\n\t\t\t**Naming Rules:**\n\t\t\t- Use only alphanumeric characters (no spaces, underscores, or dashes)\n\t\t\t- Start with an uppercase letter\n\t\t\t- Use CamelCase for multiple words\n\t\t\t- Examples: 'GitHub', 'Slack', 'GoogleDrive', 'OpenAI'\n\t\t\t\n\t\t\t**Returns:** Either immediate success or OAuth flow details for browser authentication"
    },
    {
      "name": "updateRemoteMcpServer",
      "description": "Update an existing remote MCP server with new configuration and refresh its tools list.\n\t\t\t\n\t\t\tUse this tool to update the configuration of an existing remote MCP server connection.\n\t\t\tThis allows you to change the server URL, update authentication credentials, or refresh environment variables.\n\t\t\t\n\t\t\t**Perfect for:**\n\t\t\t- Updating server URL when endpoints change\n\t\t\t- Refreshing API keys or authentication tokens\n\t\t\t- Updating environment variables or configuration\n\t\t\t- Migrating to new API versions or endpoints\n\t\t\t- Getting the latest available tools after config changes\n\t\t\t\n\t\t\t**Requirements:**\n\t\t\t- Server with the given name must already exist\n\t\t\t- New server URL must be accessible\n\t\t\t- New authentication credentials must be valid\n\t\t\t\n\t\t\t**Input Requirements:**\n\t\t\t- server_name: Name of the existing server (must match exactly and follow naming rules)\n\t\t\t- server_url: New remote server endpoint URL\n\t\t\t- env_args: Updated environment variables/configuration\n\t\t\t\n\t\t\t**Naming Rules:**\n\t\t\t- Use only alphanumeric characters (no spaces, underscores, or dashes)\n\t\t\t- Start with an uppercase letter\n\t\t\t- Use CamelCase for multiple words\n\t\t\t- Examples: 'GitHub', 'Slack', 'GoogleDrive', 'OpenAI'\n\t\t\t\n\t\t\t**Returns:** Updated server info with refreshed tools list"
    },
    {
      "name": "getUserSecrets",
      "description": "Get User Secret Keys\n\t\t\t\n\t\t\tRetrieve all available secret keys for the authenticated user. These keys can be referenced in Python code execution for MCP tool integrations, but the actual values are never exposed for security.\n\t\t\t\n\t\t\t**Perfect for:**\n\t\t\t- Discovering what secret keys are available for workflow integrations\n\t\t\t- Understanding which MCP providers are configured\n\t\t\t- Planning workflows that require authentication with external services\n\t\t\t\n\t\t\t**Returns:**\n\t\t\t- List of available secret keys with their names and providers\n\t\t\t- Metadata including total count and available providers\n\t\t\t- Usage instructions for referencing secrets in executeCode\n\t\t\t\n\t\t\t**Security Note:** Only secret key names and metadata are returned, never the actual secret values."
    },
    {
      "name": "scheduleDeployment",
      "description": "üïê Schedule a deployment to run at specific times or intervals.\n\t\t\t\n\t\t\tSet up automated execution of deployments using flexible scheduling options including:\n\t\t\t- One-time execution at a specific date/time\n\t\t\t- Recurring schedules using cron expressions\n\t\t\t- Simple interval-based schedules (daily, weekly, monthly)\n\t\t\t\n\t\t\t**Perfect for:**\n\t\t\t- Automated data processing workflows\n\t\t\t- Regular report generation\n\t\t\t- Periodic API data syncing\n\t\t\t- Scheduled backup operations\n\t\t\t- Time-based business process automation\n\t\t\t\n\t\t\t**Schedule Types:**\n\t\t\t- 'once': Execute once at a specific datetime\n\t\t\t- 'cron': Use cron expression for complex schedules\n\t\t\t- 'interval': Simple recurring intervals (daily, weekly, monthly)\n\t\t\t\n\t\t\t**Examples:**\n\t\t\t- Daily at 9 AM: schedule_type='interval', interval='daily', time='09:00'\n\t\t\t- Every Monday at 2 PM: schedule_type='cron', cron_expression='0 14 * * 1'\n\t\t\t- Once on Dec 25, 2024 at 10:30 AM: schedule_type='once', datetime='2024-12-25T10:30:00Z'"
    },
    {
      "name": "listSchedules",
      "description": "List all scheduled deployments for the current user.\n\n\t\t\tView and manage all your scheduled deployment executions with filtering and pagination options.\n\n\t\t\t**Perfect for:**\n\t\t\t- Getting an overview of all scheduled tasks\n\t\t\t- Finding specific schedules by deployment or status\n\t\t\t- Managing and monitoring scheduled executions\n\t\t\t- Planning workflow timing and coordination\n\n\t\t\t**Returns:**\n\t\t\t- List of all schedules with details\n\t\t\t- Schedule status and next execution times\n\t\t\t- Deployment information and input variables\n\t\t\t- Pagination support for large lists"
    },
    {
      "name": "memory_write",
      "description": "üíæ Write a personalized memory for the authenticated user.\n\nCapture durable preferences, ongoing work, or contextual notes so future workflows can tailor their behaviour automatically.\n\n**Great for:**\n- Remembering preferred tone or formatting\n- Storing project milestones or TODOs\n- Persisting CRM or onboarding notes\n- Tracking tool configuration choices"
    },
    {
      "name": "memory_search",
      "description": "üîç Search memories previously saved for the current user.\n\nRun semantic search across stored context to quickly retrieve preferences, project history, or tagged notes."
    },
    {
      "name": "deleteSchedule",
      "description": "üóëÔ∏è Delete a scheduled deployment permanently.\n\n\t\t\tRemove a scheduled deployment from the system. This action cannot be undone, but it will not affect any deployments that have already been executed.\n\n\t\t\t**Perfect for:**\n\t\t\t- Removing schedules that are no longer needed\n\t\t\t- Cleaning up test or temporary schedules\n\t\t\t- Managing schedule cleanup and maintenance\n\n\t\t\t**Warning:** This action is permanent and cannot be undone."
    }
  ]
}